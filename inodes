#!/bin/bash
#
# @title inodes
# ------------------------------------------------------------------------------------------
# @author Myles McNamara
# @date 11/26/2013
# @version 1.6
# @source https://gh.smyl.es/inodes
# @description Check the amount of inodes (files) in a given directory.
# ------------------------------------------------------------------------------------------
# @usage ./inodes <path>
# ------------------------------------------------------------------------------------------
# @copyright Copyright (C) 2013  Myles McNamara
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
# ------------------------------------------------------------------------------------------

# Define help function
function help(){
    echo "inodes - Count the amount of inodes in a given directory";
    echo "Usage example:";
    echo "inodes (-d|--dir) string [(-h|--help)] [(-t|--tree) integer]";
    echo "Options:";
    echo "-h or --help: Displays this information.";
    echo "-d or --dir string: Directory to scan and count inodes. Required.";
    echo "-t or --tree integer: Show tree structure above X inodes.";
    exit 1;
}

# Declare vars. Flags initalizing to 0.

# Execute getopt
ARGS=$(getopt -o "hd:t:" -l "help,dir:,tree:" -n "inodes" -- "$@");

#Bad arguments
if [ $? -ne 0 ];
then
    help;
fi

eval set -- "$ARGS";

while true; do
    case "$1" in
        -h|--help)
            shift;
            help;
            ;;
        -d|--dir)
            shift;
                    if [ -n "$1" ]; 
                    then
                        dir="$1";
                        shift;
                    fi
            ;;
        -t|--tree)
            shift;
                    if [ -n "$1" ]; 
                    then
                        tree="$1";
                        shift;
                    fi
            ;;

        --)
            shift;
            break;
            ;;
    esac
done

# Check required arguments
if [ -z "$dir" ]
then
    echo "dir not specified, using pwd";
    CURDIR=`pwd`;
else
	CURDIR=$dir;
fi

# Iterate over rest arguments called $arg
for arg in "$@"
do
    # Your code here (remove example below)
    echo $arg

done

# backup and change IFS to prevent problems with spaces in paths or file names
OLDIFS=$IFS
IFS=$'\n'

GET_SIZE(){
	du -hs $1 |cut -f 1
}
GET_COUNT(){
	find $1 |wc -l
}
SHOW_LINE(){
	echo "-----------------------------------------------------"
}
clear

format="%10s | %10s | %-20s\n"
treeformat="%10s | %10s | %-20s\n"

printf "\t\tINODE USAGE SUMMARY\n"
SHOW_LINE
printf "$format" "INODES" "SIZE" "DIRECTORY"
SHOW_LINE
	for DIR in `find $CURDIR -maxdepth 1 -type d |grep -xv $CURDIR |sort`; do 
		COUNT=$(GET_COUNT $DIR)
		SIZE=$(GET_SIZE $DIR)
		printf "$format" "$COUNT" "$SIZE" "`basename $DIR`"

		if [[ -n $tree && $COUNT -gt $tree ]]
		then
			for TREEDIR in `find $DIR -maxdepth 1 -type d |grep -xv $DIR |sort`; do 
				TREECOUNT=$(GET_COUNT $TREEDIR)
				TREESIZE=$(GET_SIZE $TREEDIR)
				printf "$treeformat" "$TREECOUNT" "$TREESIZE" "--`basename $TREEDIR`"
			done 
		fi
	done 
SHOW_LINE	
printf "$format" "$(GET_COUNT $CURDIR)" "$(GET_SIZE $CURDIR)" "$CURDIR"
SHOW_LINE

# restore IFS
IFS=$OLDIFS
